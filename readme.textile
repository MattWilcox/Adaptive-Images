h1. JavaScript Snippet for Detecting Screen Width (über-extended)

**Meant to be used with Adaptive Images and its forks, but can of course be altered to meet other needs as well.**

Since I "found out":http://www.quirksmode.org/mobile/tableViewport.html that the use of screen.width doesn’t always leave you with reliable results in conjunction with devicepixelratio, I looked for another solution to do it. And here is how.

**If you like serving for high-ppi ("retina") devices right: this is for you!**


h2. The Problem

When using AI, we rely on **screen.width** and **devicepixelratio** to detect the resolution (screen width and pixel ratio) to save it in the cookie. If we use the “long” version of the JS line to detect if a high-ppi (“retina”) device is present, we afterwards multiply the found screen width with the pixel ratio – doubling the image size to be served. This will work fine in browsers which actually return “wrong” values for screen.width: they report the theoretical screen resolution = CSS pixels = device independent pixels = dips. So what we’re basically doing is: relying on “bad behavior”; relying on a buggy and wrong implementation.

Why? Because "according to quirksmode":http://www.quirksmode.org/mobile/tableViewport.html, screen.width is actually meant to return the **real physical size** of the screen – _not the dips!_

So: if you “accidentially” serve to a browser that does it _right_, you end up doubling the already doubled screen size – ergo image size.
And if you’re like me, taking into account even device pixel ratios >2 (possible with "the fork I’m using":https://github.com/Darkwing371/Adaptive-Images-Uber-Extended), it could happen that you serve a 5760px image to a screen that has only 640px of theoretical width (worst case).


h2. The Reality Check

So is this a real world problem? Decide for yourself.

"Quirksmode":http://www.quirksmode.org/mobile/tableViewport.html reports, that on new Android phones, Blackberries, newer Nokias and on mobile Firefoxes, the screen size which screen.width would report, is based on the actual device pixels. Thus being right, it would actually cause us problems.

So with ppks compatiblity table in mind, I went downtown to do a real life countercheck. Here are my findings:

<table>
<caption>**Results of two approaches of screen width detection**</caption>
<thead>
<tr><th>Device</th><th>screen.width</th><th>mediaMatch</th></tr>
</thead>
<tbody>
<tr><td>iPad</td><td>1024,2</td><td>1024,2</td></tr>
<tr><td>iPhone 4</td><td>480,2</td><td>480,2</td></tr>
<tr><td>iPhone 5</td><td>568,2</td><td>568,2</td></tr>
<tr><td>MacBook Pro 13"</td><td>1280,2</td><td>1280,2</td></tr>
<tr><td>MackBook Pro 15"</td><td>1440,1</td><td>1440,1</td></tr>
<tr><td>MackBook Air 11"</td><td><span>*1366,1*</span></td><td><span>*1368,1*</span></td></tr>
<tr><td>MacBook Air 13"</td><td>1440,1</td><td>1440,1</td></tr>
<tr><td>Sony Xperia (Chrome)</td><td><span>*1794,3*</span></td><td>*600,3*</td></tr>
<tr><td>HTC One (Chrome)</td><td><span>*1920,3*</span></td><td>*640,3*</td></tr>
<tr><td>HTC One  X (Chrome)</td><td>1280,2</td><td>1280,2</td></tr>
<tr><td>Samsung Galaxa S III</td><td>1280,2</td><td>1280,2</td></tr>
<tr><td>Samsung Galaxy Note II</td><td>1280,2</td><td>1280,2</td></tr>
<tr><td>Samsung Galaxy Tab 2</td><td>1280,1</td><td>1280,1</td></tr>
<tr><td>Huawei Ascend</td><td>800,1.5</td><td>800,1.5</td></tr>
<tr><td>Nokia Lumia</td><td>800,1</td><td>800,1</td></tr>
</tboby>
</table>

We see it’s true: even in this quick test there are some cases **right now**, where we would actually be in trouble, when we’d try to care for high-ppi devices in the “old-fashioned way”. I’d say that on about 80% of the actual devices out there, there will be no big problems. But this might change with new devices and new browsers on new devices – and since we care for achieving excellence in being future friendly, let’s make it a 100% of compatiblity today. ;) 



h2. The Solution

I once came across "this thread on stackoverflow":http://stackoverflow.com/questions/6850164/get-the-device-width-in-javascript and became aware of the possibility using media queries via **matchMedia** in JS. I used this principle to detect the devices screen size in a small for-loop using the media queries. (Have a look at the code for details; it’s heavily commented.)

h4. Why should this be favored?

*Because it _uses_ CSS-pixels by design, because of the media queries – so it does of course return our desired dips.*

* If media queries themselfes aren’t implemented (or buggy) in a browser/device, our responsive site is in trouble anyway.
* And it can mean, that the device is _so_ old, that there is no way having a high-ppi display present.
* Or maybe it means, that there is IE < 9 running. (See first point.)

So let’s just count on having media queries available. I dare to raise the assumption, that media queries’ max-device-width is "completly implemented":http://www.browsersupport.net/CSS/%40media_%28max-device-width%29 in every browser on a new high-ppi device out there – and will be implemented "in future browsers":http://caniuse.com/#feat=matchmedia on new devices.

I’d say, that sounds pretty reliable.

And in case something should fail, we have our original one-liner to fall back to and simply abstain from serving high-ppi images. So nothing to lose here actually, **it’s progressive enhancement.**

Remember:
If this whole JavaScript thing should fail _at all_, we’ll always have a fallback in php to serve at least some appropriate image sizes.


h2. Dude, this is huge – compared to the original one-liner!

I know. This script seems totally overkill at first glance, when you got used to Matts original one line of code (that’s why my work is going by the name of **“über-extended”**). And well, I could have had this written in one line too (a long line), but I decided to comment all of my work – to make it easier to read, for understanding what and why it does things, and for others to maybe even add further improvements. 

At first I was concerned about speed of execution too, but I tested it on several occasions: it did no harm and worked reliable. A browser that would set our cookie “too late” for whatever reason, doesn’t set it too late because of JS execution time. There are other things to be held responsible for, when something like this happens. JavaScript is actually executed quicker than I thought, even on small and old mobile devices.

Nonetheless try putting the snippet on topmost location of your sites head! (And I’m pretty sure you know how to "minify":http://www.minifyjavascript.com/ it, if you want that.)



h2. So what’s the bottom line a.k.a. tl;dr?

* Don’t let our nice Adaptive Images solution rely on wrong and buggy browser implementations any more.
* Be more future friendly, especially to devices that will actually do things _right_.
* Have a more reliable and robust foundation for the math.
* Peace of mind while always having the “oldschool version” as a fallback built-in.

**Use the new JS snippet now!** … and have a gaze at the code! :)
